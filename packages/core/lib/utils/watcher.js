/*
This module wraps around a file watcher and emits events when files change
*/

const path = require("path");
const chokidar = require("chokidar");
require("colors");
const debug = require("debug")("core");
const ISDEV = process.env.NODE_ENV !== "production";
const slash = require("./fixPathSlashes");

const EventEmitter = require("events");

class FileWatcher extends EventEmitter {
  constructor(sourcePath, watch) {
    super();
    this.isWatching = false;
    this.toWatch = watch;
    this.sourcePath = sourcePath;

    this.watchDeferTimeoutID = false;
    this.pendingFilesChanged = [];
    this.isReady = false;

    // start watching files
    if (this.toWatch) {
      // chokidar glob doesn't work with backward slashes
      chokidar
        .watch(slash(path.join(this.sourcePath, "/**/*")), {
          ignoreInitial: true,
          ignored: "**/node_modules/**"
        })
        .on("ready", () => {
          debug("[WATCHING]".yellow, this.sourcePath);
          this.isWatching = true;
          this.emit("ready");
        })
        .on("add", this._onAdd.bind(this))
        .on("addDir", this._onAdd.bind(this))
        .on("change", this._onAdd.bind(this))
        .on("unlink", this._onRemove.bind(this))
        .on("unlinkDir", this._onRemove.bind(this))
        .on("error", e => debug("[ERROR]".red, e));
    } else {
      this.emit("ready");
      this.isReady = true;
    }
  }

  on(event, callback) {
    if (event === "ready" && this.isReady) {
      callback();
    }
    super.on(event, callback);
  }

  _onAdd(filePath) {
    filePath = slash(filePath);
    const relativePath = path.relative(this.sourcePath, filePath);
    if (
      relativePath.indexOf("node_modules") !== -1 ||
      relativePath.indexOf(".git") !== -1 ||
      relativePath === "yarn.lock" ||
      relativePath === "package.json" // pkg.json is generated by installPackages.js
    ) {
      return;
    }

    // don't trigger for zero-builds folder (only in dev mode)
    if (ISDEV && relativePath.indexOf("zero-builds") !== -1) {
      return;
    }
    debug("[ADD]".yellow, filePath);
    if (this.isWatching) this._emitFileChange("add", filePath);
  }

  _onRemove(filePath) {
    filePath = slash(filePath);
    const relativePath = path.relative(this.sourcePath, filePath);
    if (
      relativePath.indexOf("node_modules") !== -1 ||
      relativePath.indexOf("zero-builds") !== -1
    ) {
      return;
    }
    debug("[REM]".yellow, filePath);
    if (this.isWatching) this._emitFileChange("remove", filePath);
  }

  // emits file change events but with a delay so that files are 'settled'
  _emitFileChange(event, filePath) {
    this.pendingFilesChanged.push(filePath);
    if (this.watchDeferTimeoutID) {
      clearTimeout(this.watchDeferTimeoutID);
    }
    this.watchDeferTimeoutID = setTimeout(async () => {
      var filesArr = this.pendingFilesChanged.slice(0);
      this.pendingFilesChanged = [];
      this.emit("change", filesArr);
    }, 1000);
  }
}

module.exports = FileWatcher;
